<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>index</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="machine-learning-and-predictive-analyatics-in-health-care" class="level1">
<h1>MACHINE LEARNING AND PREDICTIVE ANALYATICS IN HEALTH CARE</h1>
<section id="a-data-driven-approach-to-disease-prediction" class="level3">
<h3 class="anchored" data-anchor-id="a-data-driven-approach-to-disease-prediction">A DATA-DRIVEN APPROACH TO DISEASE PREDICTION</h3>
</section>
<section id="table-of-contents" class="level2">
<h2 class="anchored" data-anchor-id="table-of-contents">Table of Contents</h2>
<ol type="1">
<li><a href="#introduction">Introduction</a>
<ul>
<li><a href="#Defining-the-problem">Defining the problem</a><br>
</li>
<li><a href="#context-and-background">Context and Background</a><br>
</li>
<li><a href="#objectives-and-goals">Objectives and Goals</a><br>
</li>
<li><a href="#summary-of-approach">Summary of Approach</a><br>
</li>
</ul></li>
<li><a href="#methods">Methods</a>
<ul>
<li><a href="#data-acquisition-and-sources">Data Acquisition and Sources</a><br>
</li>
<li><a href="#mathematical-and-statistical-models">Mathematical and Statistical Models</a><br>
</li>
<li><a href="#experimental-design-and-analytical-procedures">Experimental Design and Analytical Procedures</a><br>
</li>
<li><a href="#software-and-tools">Software and Tools</a><br>
</li>
<li><a href="#ethical-considerations">Ethical Considerations</a></li>
</ul></li>
<li><a href="Procedures">Procedures</a></li>
<li><a href="#results-and-discussion">Results and Discussion</a></li>
<li><a href="#conclusion">Conclusion</a><br>
</li>
<li><a href="#references">References</a></li>
</ol>
<hr>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">INTRODUCTION</h2>
<section id="defining-the-problem" class="level3">
<h3 class="anchored" data-anchor-id="defining-the-problem">DEFINING THE PROBLEM</h3>
<p>The growing patient data databases improve predictive models which allows developers to find diseases earlier when creating personalized treatments. Medical researchers deploy the Random Forest Classifier to evaluate historic healthcare data in order to identify diseases based on statistical probability. The goal involves employing machine learning methods to enhance diagnosis precision to let healthcare personnel execute early interventions and change treatment protocols.</p>
</section>
<section id="context-and-background" class="level3">
<h3 class="anchored" data-anchor-id="context-and-background">CONTEXT AND BACKGROUND</h3>
<p>Healthcare predictive analytics requires different statistical and machine learning models for analyzing structured along with unstructured data. Doctors often achieve poor results when using logistic regression due to its inability to understand complex nonlinear patterns in medical data. Robotics systems play a crucial role in healthcare because the Random Forest Classifier shows strong capabilities when dealing with large medical datasets that have value imbalances.</p>
<p>The healthcare prediction field benefits from using decision trees as well as support vector machines (SVMs) and neural networks according to previous research findings. Multiple trees combined through Random Forest outperform single decision trees since they work together to achieve more stable and accurate classifications according to Breiman (2001). The Random Forest algorithm will serve as the prediction model for assessing patient disease risk based on their medical data.</p>
</section>
<section id="objectives-and-goals" class="level3">
<h3 class="anchored" data-anchor-id="objectives-and-goals">OBJECTIVES AND GOALS</h3>
<p>For this project, we must be nearing to the goals we have set those are given as follows</p>
<ul>
<li>The implementation of Random Forest Classifier for disease prediction requires patient data processing.</li>
<li>Compare model performance against baseline classifiers such as logistic regression.</li>
<li>The model needs evaluation through accuracy measurement combined with precision rates and recall scores and AUC-ROC calculations.</li>
<li>The analysis of feature importance allows us to determine which factors serve as the main predictors for disease diagnosis.</li>
<li>Build functionality into the model which deals effectively with healthcare sector datasets that have an unbalanced distribution.</li>
<li>Achieve better performance metrics with an improved computational speed.</li>
<li>Create an easy-to-use system that enables healthcare staff to use machine learning analytic results in their work.</li>
<li>Compare model performance against baseline classifiers such as logistic regression.</li>
<li>The accuracy precision recall and AUC-ROC metrics will be used in a performance analysis of the model.</li>
<li>Use feature importance to comprehend the major disease prediction factors.</li>
</ul>
</section>
<section id="summary-of-approach" class="level3">
<h3 class="anchored" data-anchor-id="summary-of-approach">SUMMARY OF APPROACH</h3>
<section id="random-forest-classifier" class="level4">
<h4 class="anchored" data-anchor-id="random-forest-classifier">Random forest classifier</h4>
<p>The Random Forest model implementation in scikit-learn needs parameter adjustment enabled by the library to reach maximal performance levels.</p>
</section>
<section id="selecion-and-training" class="level4">
<h4 class="anchored" data-anchor-id="selecion-and-training">Selecion and training</h4>
<p>The evaluation of the model effectiveness depends on cross-validation analysis together with key performance indicators including accuracy as well as precision and recall and AUC-ROC.</p>
</section>
<section id="analysis" class="level4">
<h4 class="anchored" data-anchor-id="analysis">Analysis</h4>
<p>Embedding vital patient features related to prediction accuracy helps healthcare professionals better understand the analysis results.</p>
</section>
<section id="data-acquisition-and-preprocessing" class="level4">
<h4 class="anchored" data-anchor-id="data-acquisition-and-preprocessing">Data acquisition and preprocessing</h4>
<p>The first operational step requires dataset loading for subsequent healthcare data cleaning procedures which integrate feature engineering tasks.</p>
</section>
<section id="model-training" class="level4">
<h4 class="anchored" data-anchor-id="model-training">Model training</h4>
<p>Scikit-learn operates through the system to conduct Random Forest model training procedures.</p>
</section>
</section>
</section>
<section id="methodology" class="level2">
<h2 class="anchored" data-anchor-id="methodology">METHODOLOGY</h2>
<section id="data-acquisition-and-sources" class="level3">
<h3 class="anchored" data-anchor-id="data-acquisition-and-sources">DATA ACQUISITION AND SOURCES</h3>
<p>The “Disease Symptoms and Patient Profile Dataset” originates from Kaggle and features structured information about demographic data as well as symptoms together with diagnosed diseases. The dataset originated from healthcare records which have undergone anonymization and combined with symptom assessment reports. The preprocessing operations start with dealing with missing data elements followed by encoding categorial attributes and performing scale normalization on numerical features to enhance both consistency and model prediction accuracy.</p>
<p>An ensemble learning method called Random Forest Classifier consists of multiple decision trees in its structure. The model performs prediction on outcome by collecting decision tree predictions from multiple trees that use features .</p>
<p><span class="math display">\[
\
\hat{y} = \frac{1}{T} \sum_{t=1}^{T} h_t(x)
\
\]</span></p>
<p>The ensemble consists of trees denoted by within a total of trees. The split criterion depends on Gini Impurity which defines as:</p>
<p><span class="math display">\[
Gini = 1 - \sum_{i=1}^{n} p_i^2
\]</span></p>
<p>The formula for calculating Gini impurity includes the proportion of class in a node represented by Pi and C the total number of classes.</p>
</section>
<section id="analytical-procedrues" class="level3">
<h3 class="anchored" data-anchor-id="analytical-procedrues">ANALYTICAL PROCEDRUES</h3>
<p>A sequential guide explains how the Random Forest model should be trained along with its evaluation process:</p>
<p><img src="images/1.6.jpg" class="img-fluid"></p>
<ol type="1">
<li>The program retrieves the dataset by reading the CSV file.</li>
<li>The data needs preprocessing to handle missing values, conduct categorical variable encoding and normalize all numerical features.</li>
<li>The dataset requires division into training segments comprising 80% of the data while the remaining 20% constitutes the testing portion.</li>
<li><strong>RandomForestClassification</strong> The model gets implemented through <code>scikit-learn</code> tools while completing hyperparameter optimization for better results.
<ul>
<li>Important predictors can be determined through the application of <code>feature_importances_</code>.</li>
<li>we have to plot sensitivity versus specificity through Receiver Operating Characteristic curve plotting.</li>
<li>We need to create data visualisation through the classifier in <code>seaborn</code></li>
</ul></li>
<li>Evaluation metrics</li>
</ol>
<ul>
<li>Accuracy : the proportions of correct predictions</li>
</ul>
<p><span class="math display">\[
Accuracy = \frac{TP+TN}{TP+TN+FP+FN}
\]</span></p>
<ul>
<li>Precision : The ration of true to total predictions</li>
</ul>
<p><span class="math display">\[
Precision = \frac{TP}{TP+FP}
\]</span></p>
<ul>
<li>Recall : The ability of model to identify the predictions</li>
</ul>
<p><span class="math display">\[
Recall = \frac{TP}{TP+FN}
\]</span></p>
<p>TP : True Positives</p>
<p>TN : True Negatives</p>
<p>FP : False Positives</p>
<p>FN : False Negatives</p>
</section>
<section id="softwares-and-tools" class="level3">
<h3 class="anchored" data-anchor-id="softwares-and-tools">SOFTWARES AND TOOLS</h3>
<p>The platform I used is Python together with its library components:</p>
<ul>
<li><code>Pandas</code> for data manipulation.</li>
<li>The implementation of <code>Random forest classifier</code> happens through scikit-learn framework.</li>
<li><code>Matplotlib</code> and <code>Seaborn</code> for data visualization.</li>
<li><code>Numpy</code> is used for numerical computations and arrays handling.</li>
<li><code>Google Colab</code> is used for cloud based computations and handling the code exeutions without GPU/CPU.</li>
</ul>
</section>
</section>
<section id="procedures" class="level2">
<h2 class="anchored" data-anchor-id="procedures">PROCEDURES</h2>
<p><strong>STEP-1</strong> We need to install the necessary libraries</p>
<pre><code>import pandas as pd
import numpy as np
import matplotlib.pyplot as plt</code></pre>
<p><strong>STEP-2 IMPORT SCIKIT-LEARN TOOLS</strong></p>
<p>Installing <code>scikit-learn</code> for data splitting, Scaling, Modeling and Evaluation</p>
<pre><code>from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix, roc_auc_score, roc_curve</code></pre>
<p><strong>STEP-3 LOADING THE DATASET</strong></p>
<pre><code>data = pd.read_csv("/content/Disease_symptom_and_patient_profile_dataset.csv")</code></pre>
<pre><code>data.info()
data.head(5)
data.shape</code></pre>
<p><img src="images/1.1.jpeg" class="img-fluid"></p>
<p><strong>STEP-4 DATA CLEANING AND ENCODING</strong> Now after data skimming and trimming we need to categorize the variables in the dataset.</p>
<pre><code>label_encoders = {}
for col in df.columns:
    if df[col].dtype == 'object':
        le = LabelEncoder()
        df[col] = le.fit_transform(df[col])
        label_encoders[col] = le</code></pre>
<p><strong>STEP-5 TRAIN-TEST SPLIT AND MODEL TRAINING</strong></p>
<pre><code>X = df.drop(columns=['Outcome Variable'])
y = df['Outcome Variable']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

rf = RandomForestClassifier(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)
y_pred = rf.predict(X_test)</code></pre>
<p><strong>STEP-6</strong> <strong>MODEL EVALUATION</strong></p>
<pre><code>accuracy = accuracy_score(y_test, y_pred)
conf_matrix = confusion_matrix(y_test, y_pred)
class_report = classification_report(y_test, y_pred)

print(f'Accuracy: {accuracy:.2f}')
print('Confusion Matrix:\n', conf_matrix)
print('Classification Report:\n', class_report)</code></pre>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/1.2.jpeg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p><strong>STEP-7</strong> <strong>DATA VISUALISATION</strong></p>
<section id="a.feature-importance-plot" class="level4">
<h4 class="anchored" data-anchor-id="a.feature-importance-plot">A.Feature importance plot</h4>
<pre><code>feature_importances = pd.Series(rf.feature_importances_, index=X.columns).sort_values(ascending=False)
plt.figure(figsize=(10, 6))
sns.barplot(x=feature_importances, y=feature_importances.index)
plt.xlabel('Importance Score')
plt.ylabel('Features')
plt.title('Feature Importance in Random Forest')
plt.show()</code></pre>
<p><strong>VISUALISATION FOR THE FEATURE IMPORTANCE</strong></p>
<p><img src="images/1.3.jpeg" class="img-fluid"></p>
<p>####&nbsp; B.Confusion matrix Heatmap</p>
<pre><code>plt.figure(figsize=(6, 4))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=label_encoders['Outcome Variable'].classes_, yticklabels=label_encoders['Outcome Variable'].classes_)
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()</code></pre>
<p><strong>CONFUSION MATRIX - ACTUAL VS PREDICTED</strong></p>
<p><img src="images/1.4.jpeg" class="img-fluid"></p>
<p>Now based on the data given and predictions taken from the dataset, now we make model to predict the diseases bsed on the symptoms we input to it</p>
<p><strong>STEP-8</strong> <strong>DISEASE PREDICTION</strong></p>
<pre><code>def predict_disease():
    user_input = {}
    for col in X.columns:
        if col in label_encoders:
            options = list(label_encoders[col].classes_)
            print(f"Select {col} ({', '.join(options)}): ")
            value = input()
            user_input[col] = label_encoders[col].transform([value])[0]
        else:
            value = input(f"Enter {col}: ")
            user_input[col] = int(value)

    input_df = pd.DataFrame([user_input])
    prediction = rf.predict(input_df)[0]
    predicted_disease = label_encoders['Outcome Variable'].inverse_transform([prediction])[0]
    print(f"Predicted Outcome: {predicted_disease}")

if __name__ == "__main__":
    predict_disease()</code></pre>
<p><strong>MODEL INPUTS</strong></p>
<p><img src="images/1.5.jpeg" class="img-fluid"></p>
</section>
</section>
<section id="results-and-discussions" class="level2">
<h2 class="anchored" data-anchor-id="results-and-discussions">RESULTS AND DISCUSSIONS</h2>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>